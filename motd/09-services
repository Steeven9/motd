#!/usr/bin/env bash

set -euo pipefail

source /etc/update-motd.d/colors.txt

# Maintain proper order when adding items to services_order
declare -A services
declare -a services_order

# value is pretty name

services["docker"]="Docker"
services_order+=("docker")

services["freepbx"]="FreePBX"
services_order+=("freepbx")

services["beszel-agent"]="Monitoring"
services_order+=("beszel-agent")

services["pihole-FTL"]="PiHole"
services_order+=("pihole-FTL")

services["wyoming-staellite"]="Wyoming"
services_order+=("wyoming-staellite")

# Max width used for components in second column
WIDTH="${WIDTH:-100}"

# Prints given blocks of text side by side
# $1 - left column
# $2 - right column
print_columns() {
    [[ -z $2 ]] && return
    paste <(echo -e "${CN}$1${1:+:}${CN}") <(echo -e "$2")
}

# Prints text as either acitve or inactive
# $1 - text to print
# $2 - literal "active" or "inactive"
print_status() {
    local out=""
    if [[ $2 == "active" ]]; then
        out+="${CO}▲${CN}"
    else
        out+="${CE}▼${CN}"
    fi
    out+=" $1${CN}"
    echo "${out}"
}

# Prints comma-separated arguments wrapped to the given width
# $1 - width to wrap to
# $2, $3, ... - values to print
print_wrap() {
    local width=$1
    shift
    local out=""
    local line_length=0
    for element in "$@"; do
        element="${element} |"
        local visible_elelement future_length
        visible_elelement=$(strip_ansi "${element}")
        future_length=$((line_length + ${#visible_elelement}))
        if [[ ${line_length} -ne 0 && ${future_length} -gt ${width} ]]; then
            out+="\n"
            line_length=0
        fi
        out+="${element} "
        line_length=$((line_length + ${#visible_elelement}))
    done
    [[ -n "${out}" ]] && echo "${out::-2}"
}

# Strips ANSI color codes from given string
# $1 - text to strip
strip_ansi() {
    echo -e "$1" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}

statuses=()
for key in "${services_order[@]}"; do
    if [ $key = "ufw" ] && command -v ufw 2>&1 >/dev/null; then
        if sudo ufw status | grep -q "Status: active"; then
            statuses+=("$(print_status "${services[${key}]} - active" "active")")
        else
            statuses+=("$(print_status "${services[${key}]} - inactive" "inactive")")
        fi
    elif [ $key = "marzban" ] && command -v marzban 2>&1 >/dev/null; then
        if sudo marzban status | ansi2txt | grep -q "marzban: running"; then
            statuses+=("$(print_status "${services[${key}]}" "active")")
        else
            statuses+=("$(print_status "${services[${key}]}" "inactive")")
        fi
    else
        if [[ $(systemctl list-unit-files "${key}*" | wc -l) -gt 3 ]]; then
            status=$(systemctl show -p ActiveState --value "${key}")
            statuses+=("$(print_status "${services[${key}]}" "${status}")")
        fi
    fi
done

text="\b"
text+=$(print_wrap "${WIDTH}" "${statuses[@]}")

print_columns " Services............" "${text}"
